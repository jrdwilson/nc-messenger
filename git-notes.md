# Git & Best Practices for Project Phase

## Prior Knowledge

- Know what version a version control system is
- Know how to use Git with a single branch
- Know how to interact with GitHub repositories

## Learning Objectives

- Follow specific conventions for commit messages
- Use Git branches
- Protect branches on GitHub
- Make Pull Requests on GitHub
- Use strategies to make a project with many team members more manageable

## Introduction

Each company will have their own opinions about how version control should be done depending on their needs. Some might use hosts other than GitHub, such as [GitLab](https://about.gitlab.com/), or [BitBucket](https://bitbucket.org/product/) - sometimes on their own servers too. They might not even use Git as their version control system - [Mercurial](https://www.mercurial-scm.org/) and [CVS](https://nongnu.org/cvs/) are alternatives. Here, we will look in more detail at some of the many conventions and tools you can use to better coordinate a group project.

## Commit Messages

If you have the word 'and' in a commit subject, this should probably be two commits! We recommend writing [commit messages](https://medium.com/@steveamaza/how-to-write-a-proper-git-commit-message-e028865e5791) in the imperative, present tense:

> Write your commit message in the imperative: “Fix bug” and not “Fixed bug” or “Fixes bug.” This convention matches up with commit messages generated by commands like git merge and git revert.
> Although many people don't follow this specific convention. It's certainly nice to follow _a convention_ as a team.
> To add a simple Git commit message: `git commit -m "commit message subject"`

- When working in a team, you might want to justify (or just explain further) the changes that you have made, especially if you are working on technology which is new to some of you. This extra information can be added to the "body" of a commit message:

```
<subject>
<BLANK LINE>
<body>
```

To add a detailed Git commit message: `git commit`. This will open up your default text editor - probably [Vim](https://stackoverflow.com/questions/6098742/using-git-commit-a-with-vim) although you can [configure this](https://code.visualstudio.com/docs/editor/versioncontrol#_vs-code-as-git-editor) if you prefer.
There are many more things we can do with commit messages that we won't go into but there is even [tooling](https://github.com/commitizen/cz-cli) built to ensure people follow certain rules when writing commit messages.

## Branches

[Branches](https://www.atlassian.com/git/tutorials/using-branches) are a better way to maintain responsibility within your code and make it easier to keep track of what is happening and the different features people are working on.

- To create a new branch locally, `git checkout -b new-branch`. -b tag means this should be a new branch.
- Give this branch a short name representing the feature you are implementing.
- We can make changes, add and commit code that relates to this feature, as many times as we like.
- When we are happy with the feature and that it should become a permanent feature of our application, then it is time to combine it with the latest code in your `master` branch before pushing it up to GitHub:

```sh
git pull origin master # pull the latest changes on master from your origin remote
git checkout new-branch # move to your new branch
git merge master # combine the any changes with master with your new branch
git push origin new-branch # push the changes on the new branch to GitHub
```

- Sometimes, when you try to merge two branches, there will be [merge conflicts](https://www.atlassian.com/git/tutorials/using-branches/merge-conflicts). These occur when the same lines of code in the same files have been edited concurrently. `git status` is a good way to identify which files are causing the conflicts. VS Code has a [really nice interface](https://code.visualstudio.com/Docs/editor/versioncontrol#_merge-conflicts) for solving these conflicts (as well as diffing files that have been modified since a previous commit). Solve the conflicts by selecting which changes you want to keep. Once you have solved the conflicts, you will want to `git add` and `git commit` these changes before pushing.
- On GitHub, recent branch pushes are flagged at the top of a repo (or you can go to the branches menu to see activity). We have the option to make a pull request - think of this as asking permission for your code to be pulled into the master branch, rather than pushing your code in.
- Assuming there are no merge conflicts (you'll have to pull in the code and sort them out first if there are, or else use the GitHub console if it's simple enough) you might be tempted by the big green merge button - but much better to seek approval from someone else. Request a review, leave a nice simple message, and assign someone to look at it.
- That person can take a look at the code, and either comment, approve or request changes. When we get round to protecting our branch later, we can specify that approval is necessary for merging to happen.
- The original pull-requester is now free to merge in! You can safely delete the branch - it's not gone forever should it come to it, but it stops it clogging up your branch list.
- Now the code is pushed in on your GitHub remote, but you want your local machine to reflect that. `git checkout master` will take you back to the master branch. `git pull origin master` will get in the changes from GitHub, so you are up to date locally. You can delete the branch locally with `git branch -D new-branch`.

## Stay safe

You should think of your master branch as production ready code. It's up to you to decide exactly what that means, but a guide might be code that you could deploy and it would work fully within the limitations of whatever features you had covered. Certainly, you don't want to risk non-functioning code getting into the master branch.

- We should also enable some protections to master. The first is to require approval on pull requests before merging. The person who approves the code should not be the person who wrote it! Ideally you pull in another pair to do this, but sometimes, when that's not possible, one of your pair can submit the request, and the second should read it to approve. It's also a good idea to extend these restrictions to administrators whilst we're here - so nobody is above the law!

## Rebasing

Rebasing is an alternative to merging. Instead of amalgamating to commit histories from two different branches so as to reflect the time the commits were made, it restructures the commit history so that one branch's features appeared to have based from another. This is great for when two people are working on two branches from the same root simultaneously.
You can see this more visually and look at some of the pros and cons of merging and rebasing on [Atlassian's page on this matter](https://www.atlassian.com/git/tutorials/merging-vs-rebasing).

## Enforcing Rules on a Repository

### ESLint

It is highly recommended that you use [ESLint](https://eslint.org/docs/user-guide/getting-started)
ESLint imposes a set of rules that your code has to follow.
**Advantages:**

- You will find bugs and errors before they happen.
- Makes code more consistent across developers - therefore easier to read.
- Can clean up commits (imagine if one person working on a repo had different rules for single / double quotes - looking through a git diff would be awful)
- Install: `npm install eslint --save-dev`
- Initialise: `./node_modules/.bin/eslint --init`
- Choose a styleguide to start off with (you can adjust the rules as we go along). Airbnb is good, especially with React.
  You can also look at creating a [workspace settings](https://code.visualstudio.com/docs/getstarted/settings) file. This can make the preferences the same for any of the editors working on the project. Things like format on save and rules for [Prettier](https://prettier.io/).

### Git Hooks with Husky

[Husky](https://github.com/typicode/husky) allows us to easily add "git hooks" to our project.
Git hooks can prevent a bad push or commit from happening.
`npm install husky --save-dev`
These hooks will run the tests and linting (auto-fixing where possible) before each commit:

```json
{
  "husky": {
    "hooks": {
      "precommit": "npm t",
      "posttest": "eslint ./ --fix"
    }
  }
}
```
